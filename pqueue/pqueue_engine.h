#include <fstream>
#include <optional>
#include <vector>
#include <iostream>
#include <deque>
#include <nlohmann/json.hpp>

namespace persistent_queue {    
    struct File_Marker {
        unsigned long position;
        bool deleted;

        File_Marker(unsigned long position);
    };

    struct Chunk {
        unsigned long position;
        std::vector<File_Marker> fms;
        std::vector<File_Marker>::iterator oldest_item_fm;
        bool isEmpty();
        Chunk(unsigned long position);
    };

    template <typename T, typename Container = std::deque<T>>
    class Engine {
    public:
        Engine(std::fstream& file);

        using size_type = unsigned long;
        size_type buffer_size = 64;

        void enqueue(const T& elem);
        std::optional<T> dequeue(); 

        void flush();
        void load();

        size_type size();
    private:
        Container enqueue_buffer; 
        Container dequeue_buffer;
        std::fstream& file;
        std::deque<Chunk> file_chunks;

        size_type saved_sz;
        size_type sz;
    };


    template <typename T, typename Container>
    Engine<T, Container>::Engine(std::fstream& file):
        file{file},
        sz{0}
        {}

    template <typename T, typename Container>
    Engine<T, Container>::size_type Engine<T, Container>::size()
        { return sz; }

    template <typename T, typename Container> 
    void Engine<T, Container>::enqueue(const T& elem) {
        enqueue_buffer.push_front(elem);

        if (enqueue_buffer.size() >= buffer_size)
            flush();
    }

    template <typename T, typename Container>
    std::optional<T> Engine<T, Container>::dequeue() {
        std::optional<T> value_container;

        T* value;

        if (dequeue_buffer.size() == 0) 
            load();
       
        if (dequeue_buffer.size() > 0)
            *value_container = value;

        return value_container;
    }

    template <typename T, typename Container> 
    void Engine<T, Container>::flush() {
        auto it = enqueue_buffer.begin();
        size_type file_position = file.tellg();
        Chunk file_chunk {file_position};
        for (int i = 0; it != enqueue_buffer.end() && i < buffer_size; ++it, ++i) {
            file_chunk.fms.push_back(File_Marker{file_position});
            file_chunk.oldest_item_fm = file_chunk.fms.end() - 1;
            file << *it;
            ++saved_sz;
        }
        file_chunks.push_back(file_chunk);
        enqueue_buffer.clear();
    }

    template <typename T, typename Container> 
    void Engine<T, Container>::load() {
        if (file_chunks.size() == 0) {
            for (int i = 0; i < enqueue_buffer.size(); ++i) {
                dequeue_buffer.push_front(enqueue_buffer[i]);
            }
            enqueue_buffer.clear();
        }else {
            Chunk first_chunk = file_chunks.front();
            file_chunks.pop_front();
            auto oldest_item_fm = first_chunk.oldest_item_fm;

            while (oldest_item_fm != first_chunk.fms.begin()) {
                if (!oldest_item_fm->deleted) {
                    file.seekg(oldest_item_fm->position);
                    T* value;
                    file >> value;
                    dequeue_buffer.push_front(*value);
                    oldest_item_fm->deleted = true;
                    --oldest_item_fm;
                }
            }

            if (!oldest_item_fm->deleted) {
                file.seekg(oldest_item_fm->position);
                T* value;
                file >> value;
                dequeue_buffer.push_front(*value);
                oldest_item_fm->deleted = true;
                first_chunk.oldest_item_fm = first_chunk.fms.end();
            }
        }
    }

//    // work flow:
//    // enqueue/dequeue (wrapper around data structure) 
//    // flush (flushes all in memory stuff to database manually (should be automatic though)
//    // serialize (converts data structure into in memory stuff);
//    // buffer (gets current buffer (in memory data structure)
//    template <typename T, typename Container = std::deque<T>>
//    class Engine {
//        public:
//            // eventualy; switch to using file chunk_size
//            // prefix auto generated by object 
//            // keep track of chunks vector (all file strings)
//            // have map of chunk strings and fstreams
//            // delete when chunks become empty
//            Engine(std::fstream& file);
//
//            using size_type = unsigned long;
//            size_type buffer_size = 64;
//            size_type chunk_size = 1024;
//
//            void enqueue(const T& elem);
//
////            template <typename Batch_Container>
////            void enqueueBatch(const Batch_Container& batch);
//
//            std::optional<T> dequeue();
////            template <typename Batch_Container>
////            Batch_Container dequeueBatch(size_t count);
//            std::optional<T> peek() const;
//
//            // flush to file
//            void flush();
//            void load();
//
//            const Container& buffer() const;
//
//            size_type size(); // size of pqueue
//            bool isEmpty();
//            size_type capacity(); // remaining buffer space
//
//            void clear();
//        private:
//            Container memory_buffer;
//            std::fstream file;
//            std::vector<File_Marker> file_markers;
//            std::vector<File_Marker>::iterator last_file_marker;
//            std::deque<Chunk> chunks;
//            size_type sz;
//            size_type saved_sz;
//
//            void serialize(Container& batch);
//            std::optional<T> dequeueFromBuffer();
//            std::optional<T> dequeueFromFile();
//    };
//
//    template<typename Container, typename T>
//    Engine<Container, T>::Engine(std::fstream& file):
//        file{std::move(file)},
//        sz{0},
//        saved_sz{0},
//        last_file_marker(file_markers.end())    
//    {
//    }
//
//    template <typename T, typename Container>
//    void Engine<T, Container>::enqueue(const T& elem) {
//        auto begin = memory_buffer.begin();
//        memory_buffer.insert(begin, elem);
//        sz++;
//        if (sz == buffer_size)
//            flush();
//    }
//
//    template <typename T, typename Container>
//    std::optional<T> Engine<T, Container>::dequeue() {
//        std::optional<T> elem;
//        if (saved_sz > 0) {
//            elem = dequeueFromFile();
//        } else {
//            elem = dequeueFromBuffer(); 
//        }
//        return elem;
//    }
//
//    template <typename T, typename Container>
//    std::optional<T> Engine<T, Container>::dequeueFromFile() {
//        std::optional<T> elem{};
//        T value;
//
//        if (last_file_marker == file_markers.end())
//            return elem; 
//
//        file.seekg(last_file_marker->position);
//        file >> value;
//        *elem = value;
//
//        file.seekg(0);
//
//        last_file_marker->deleted = true;
//
//        while (last_file_marker != file_markers.begin()) {
//            --last_file_marker;
//            if (!last_file_marker->deleted)
//                break;
//        }
//
//        if (last_file_marker->deleted) {
//            last_file_marker = file_markers.end();
//            chunks.pop_front();
//        }
//
//        --saved_sz;
//        --sz;
//
//        return elem;
//    }
//
//    template <typename T, typename Container>
//    std::optional<T> Engine<T, Container>::dequeueFromBuffer() {
//        std::optional<T> elem;
//
//        if (memory_buffer.size() == 0)
//            return elem;
//
//        *elem = memory_buffer.back();
//        memory_buffer.pop_back();
//
//        return elem;
//    }
//
//    template <typename T, typename Container>
//    void Engine<T, Container>::flush() {
//        std::cout << "Flushing\n";
//        auto it = memory_buffer.begin();
//        for (int i = 0; i < buffer_size && it != memory_buffer.end(); ++it, ++i) {
//            unsigned long file_position = file.tellg();
//            if (i == 0) {
//                chunks.push_front(Chunk{file_position});
//            }
//            file_markers.push_back(File_Marker{file_position});
//            file << *it << ',';
//            last_file_marker = file_markers.end()-1;
//            ++saved_sz;
////            std::cout << "Last file marker: " << last_file_marker->position << '\n';
//        }
//
//        memory_buffer.clear();
//        sz = 0;
//    }
//
//    template<typename T, typename Container> 
//    typename Engine<T, Container>::size_type Engine<T, Container>::size() {
//        return sz;
//    }
//
//    template<typename T, typename Container>
//    bool Engine<T, Container>::isEmpty() {
//        return sz == 0; 
//    }
//
//    template<typename T, typename Container>
//    typename Engine<T, Container>::size_type Engine<T, Container>::capacity() {
//        return buffer_size - sz;
//    }
};
